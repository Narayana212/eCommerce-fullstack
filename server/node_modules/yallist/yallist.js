'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

/**
 * Creates a new Yallist instance or initializes an existing one.
 * @param {Array|Iterable} [list] - An optional array or iterable object to initialize the list with.
 * @returns {Yallist} A new or initialized Yallist instance.
 */
function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    /**
     * Iterates over each item in the given list and pushes it to the current object.
     * @param {Array} list - The array of items to be processed.
     * @returns {void} This method does not return a value.
     */
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

/**
 * Removes a node from the Yallist (doubly-linked list).
 * @param {Object} node - The node to be removed from the list.
 * @returns {Object|null} The next node in the list after removal, or null if there is no next node.
 */
Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

/**
 * Adds a node to the beginning of the linked list.
 * @param {Object} node - The node to be added to the beginning of the list.
 * @returns {undefined} This method does not return a value.
 */
Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

/**
 * Pushes a node to the end of the linked list
 * @param {Object} node - The node to be pushed to the list
 * @returns {undefined} This method doesn't return a value
 */
Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    /**
     * Adds one or more elements to the end of the Yallist and returns the new length
     * @param {...*} elements - The element(s) to add to the end of the Yallist
     * @returns {number} The new length of the Yallist after adding the elements
     */
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  /**
   * Adds one or more elements to the beginning of the Yallist and returns the new length.
   * @param {...*} elements - The elements to add to the beginning of the Yallist.
   * @returns {number} The new length of the Yallist after the elements have been added.
   */
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

/**
 * Removes and returns the last element from the linked list.
 * @returns {*} The value of the removed last element, or undefined if the list is empty.
 */
Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

```
/**
 * Removes and returns the first element from the linked list.
 * @returns {*} The value of the first element, or undefined if the list is empty.
 */

```Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  /**
   * Iterates through the list and applies a function to each element.
   * @param {Function} fn - The function to be called for each element. It receives three arguments: the current element's value, its index, and the list itself.
   * @param {Object} [thisp] - The context object to be used as 'this' in the function. If not provided, the list itself is used.
   * @returns {undefined} This method does not return a value.
   */
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  /**
   * Iterates through the list in reverse order, calling a function for each element.
   * @param {Function} fn - The function to call for each element. It receives three arguments:
   *                        the element's value, its index, and the list itself.
   * @param {Object} [thisp=this] - The context object to use as 'this' in the function calls.
   * @returns {undefined} This method doesn't return a value.
   */
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

/**
 * Retrieves the value at the specified index in the linked list.
 * @param {number} n - The index of the element to retrieve.
 * @returns {*} The value at the specified index, or undefined if the index is out of bounds.
 */
Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

/**
 * Retrieves the value of the nth node from the end of the linked list.
 * @param {number} n - The position from the end of the list (1-indexed).
 * @returns {*} The value of the nth node from the end, or undefined if n is out of bounds or a cycle is detected.
 */
Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

/**
 * Maps over the list in reverse order and returns a new Yallist with the results.
 * @param {Function} fn - The mapping function to apply to each element.
 * @param {Object} [thisp=this] - The context object to use as 'this' in the mapping function.
 * @returns {Yallist} A new Yallist containing the mapped values in reverse order.
 */
/**
 * Maps each value in the list to a new value using the provided function.
 * @param {Function} fn - The mapping function to apply to each value.
 * @param {*} [thisp=this] - The context to use as 'this' when calling the mapping function.
 * @returns {Yallist} A new Yallist containing the mapped values.
 */
Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
/**
 * Reduces the list in reverse order, applying a function to each element and accumulating the result.
 * @param {Function} fn - The reducer function to apply to each element. It takes three arguments: accumulator, current value, and index.
 * @param {*} [initial] - The initial value for the accumulator. If not provided, the last element of the list is used as the initial value.
 * @returns {*} The final accumulated value after applying the reducer function to all elements.
 * @throws {TypeError} If the list is empty and no initial value is provided.
 */
}

/**
 * Reduces the list to a single value using a reducer function
 * @param {Function} fn - The reducer function to apply to each element
 * @param {*} [initial] - The initial value for the reduction (optional)
 * @returns {*} The final accumulated value after applying the reducer to all elements
 */
Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

```
/**
 * Converts the linked list to an array
 * @returns {Array} An array containing all the values of the linked list in order
 */

```Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

/**
 * Converts the linked list to an array in reverse order.
 * @returns {Array} An array containing the values of the linked list in reverse order.
 */
Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

/**
 * Slices the Yallist and returns a new Yallist containing the specified range of elements.
 * @param {number} [from=0] - The starting index of the slice (inclusive). Negative values are offset from the end.
 * @param {number} [to=this.length] - The ending index of the slice (exclusive). Negative values are offset from the end.
 * @returns {Yallist} A new Yallist containing the elements from the specified range.
 */
Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  /**
   * Creates a new Yallist containing elements from the original list in reverse order, within the specified range.
   * @param {number} [from=0] - The starting index of the range (inclusive). Negative values are offset from the end of the list.
   * @param {number} [to=this.length] - The ending index of the range (exclusive). Negative values are offset from the end of the list.
   * @returns {Yallist} A new Yallist containing the reversed slice of elements.
   */
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

/**
 * Splices the Yallist, removing a portion of the list and optionally inserting new nodes.
 * @param {number} start - The index at which to begin changing the list.
 * @param {number} deleteCount - The number of nodes to remove from the list.
 * @param {...*} nodes - The nodes to insert into the list.
 * @returns {Array} An array containing the removed nodes.
 */
Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  /**
   * Inserts a new node with the given value into the linked list.
   * @param {Object} self - The linked list object.
   * @param {Object} node - The node after which to insert the new node.
   * @param {*} value - The value to be stored in the new node.
   * @returns {Object} The newly inserted node.
   */
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

/**
 * Reverses the order of elements in the linked list.
 * @param {void} - This method doesn't take any parameters.
 * @returns {Yallist} The reversed list instance.
 */
Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  ```
  /**
   * Adds a new item to the end of the linked list.
   * @param {Object} self - The linked list object.
   * @param {*} item - The item to be added to the list.
   * @returns {undefined} This function does not return a value.
   */
  ```
  /**
   * Adds a new item to the beginning of the linked list.
   * @param {Object} self - The linked list object.
   * @param {*} item - The item to be added to the beginning of the list.
   * @returns {undefined} This method does not return a value.
   */
  self.length++

  /**
   * Creates a new Node instance for a doubly linked list
   * @param {*} value - The value to be stored in the node
   * @param {Node|null} prev - The previous node in the list
   * @param {Node|null} next - The next node in the list
   * @param {Object} list - The list object this node belongs to
   * @returns {Node} A new Node instance
   */
  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist)
} catch (er) {}
